<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sleeper League Dashboard</title>
<style>
  :root {
    --bg: #0f1115; --surface: #171925; --surface-2: #1e2130;
    --text: #e6e7ee; --muted: #a6abc8; --border: #2a2f45;
    --accent: #7b6ff7; --accent-2: #22c1ee; --good: #36d399; --warn: #f6c859; --bad: #ef6b73;
    --radius: 14px; --shadow: 0 10px 30px rgba(0,0,0,0.35);
  }
  html, body { height:100%; background:var(--bg); color:var(--text); }
  body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
  header {
    display:flex; gap:16px; flex-wrap:wrap; align-items:flex-end; margin-bottom: 18px;
    padding:16px; border:1px solid var(--border); border-radius: var(--radius);
    background: linear-gradient(180deg, var(--surface) 0%, var(--surface-2) 100%); box-shadow: var(--shadow);
  }
  nav.tabs { display:flex; gap:8px; margin: 10px 0 0; flex-wrap: wrap; }
  .tabbtn {
    height:36px; padding:0 12px; border-radius:10px; border:1px solid var(--border);
    background: linear-gradient(180deg, var(--surface-2) 0%, var(--surface) 100%);
    color: var(--text); cursor:pointer;
  }
  .tabbtn.active { background: linear-gradient(180deg, var(--accent) 0%, #5c52d8 100%); border:none; color:white; box-shadow: 0 6px 18px rgba(123,111,247,0.35) }
  label { font-size:12px; color:var(--muted); }
  input, button, select { height:40px; border-radius:12px; border:1px solid var(--border); background:#0d0f16; color:var(--text); padding:0 12px; outline:none; }
  input[type=number] { width: 96px; text-align:center; }
  button.primary { background: linear-gradient(180deg, var(--accent) 0%, #5c52d8 100%); border: none; color:white; font-weight:600; cursor:pointer; padding:0 14px; box-shadow: 0 6px 18px rgba(123,111,247,0.35); }
  button.secondary { background: linear-gradient(180deg, var(--surface-2) 0%, var(--surface) 100%); border:1px solid var(--border); color: var(--text); }
  button:hover { filter: brightness(1.05); }
  .bar { display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end; }
  .note { margin-left:auto; display:flex; align-items:center; gap:8px; color:var(--muted); }
  .dot { width:8px; height:8px; border-radius:50%; background: var(--accent-2); opacity:.85; }
  .view { display:none; } .view.active { display:block; }
  .grid { display:grid; grid-template-columns: repeat(auto-fit,minmax(360px,1fr)); gap:20px; }
  section {
    border:1px solid var(--border); border-radius: var(--radius); padding:16px;
    background: linear-gradient(180deg, var(--surface) 0%, var(--surface-2) 100%); box-shadow: var(--shadow); min-width:320px;
  }
  h2 { margin:0 0 12px; font-size:18px; letter-spacing: .2px; }
  .muted { color: var(--muted); font-size:12px; }
  .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; font-weight:600; background:#111528; border:1px solid var(--border); color:var(--muted); }

  table { width:100%; border-collapse: collapse; font-size:13px; }
  th, td { border-bottom:1px solid var(--border); padding:10px 8px; text-align:left; vertical-align: middle; }
  th { background: #14172a; color:#cfd2f0; position:sticky; top:0; z-index:1; }
  tr:hover td { background:#151a2f66; }

  .cards { display:grid; grid-template-columns: repeat(auto-fit,minmax(260px,1fr)); gap:14px; }
  .card {
    border:1px solid var(--border); border-radius:12px; padding:14px;
    background: linear-gradient(180deg, #171a28 0%, #121624 100%);
  }
  .card h3 { margin:0 0 6px; font-size:16px; }
  .card .kv { font-size:13px; color:var(--muted); display:flex; justify-content:space-between; margin:2px 0; }
  .link { color: var(--accent-2); text-decoration: underline; cursor: pointer; }
  canvas { max-height: 360px; }

  .namecell { display:flex; align-items:center; gap:8px; }
  .avatar { width:22px; height:22px; border-radius:50%; object-fit:cover; display:inline-block; }
  .avatar-sm { width:18px; height:18px; border-radius:50%; object-fit:cover; }
  .avatar-initial, .avatar-initial-sm {
    background:#2a2f45; color:#cfd2f0; display:inline-flex; align-items:center; justify-content:center; font-weight:700;
  }
  .avatar-initial { width:22px; height:22px; font-size:12px; border-radius:50%; }
  .avatar-initial-sm { width:18px; height:18px; font-size:11px; border-radius:50%; }

  .preview-card { display:flex; flex-direction:column; gap:10px; }
  .preview-meta { display:flex; gap:8px; flex-wrap:wrap; color:var(--muted); font-size:12px; }
  textarea.preview {
    width:100%; min-height:140px; resize:vertical; border-radius:12px; border:1px solid var(--border); background:#0d0f16; color:var(--text); padding:10px 12px; line-height:1.35;
  }
  .btnrow { display:flex; gap:8px; flex-wrap:wrap; }
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
</head>
<body>

<header>
  <div class="bar" style="flex:1 1 auto; gap:16px;">
    <div>
      <label for="week">Week</label><br/>
      <input id="week" type="number" min="1" max="18" value="1">
    </div>
    <div style="display:flex; gap:10px;">
      <button id="autoWeekBtn" class="secondary" title="Detect current NFL week">Auto Week</button>
      <button id="loadBtn" class="primary">Load Current Season</button>
      <button id="matchupsBtn" class="secondary">Load Matchups</button>
    </div>
    <div id="seasonNote" class="note"><span class="dot"></span><span>Ready</span></div>
  </div>

  <nav class="tabs" style="width:100%;">
    <button class="tabbtn active" data-tab="dashboard">Dashboard</button>
    <button class="tabbtn" data-tab="previews">Previews</button>
    <button class="tabbtn" data-tab="alltime">All-Time</button>
    <button class="tabbtn" data-tab="seasons">Seasons</button>
    <button class="tabbtn" data-tab="seasonDetail">Season Detail</button>
  </nav>
</header>

<!-- DASHBOARD -->
<div id="dashboard" class="view active">
  <div class="grid">
    <section>
      <h2>League Info</h2>
      <div id="leagueInfo" class="muted">—</div>
    </section>

    <section>
      <h2>Power Rankings <span class="pill">PF-weighted</span></h2>
      <div id="powerWrap"></div>
      <div class="muted" style="margin-top:6px;">Weights: PF 55% • Wins 25% • MOV 10% • Recent 10%</div>
    </section>

    <section>
      <h2>Standings <span class="pill">Wins → PF</span></h2>
      <div id="standingsWrap"></div>
    </section>

    <section>
      <h2>Rosters</h2>
      <div id="rostersWrap"></div>
    </section>

    <section>
      <h2>Matchups (selected week)</h2>
      <div id="matchupsWrap" class="muted">Enter a week and click “Load Matchups”.</div>
    </section>

    <section>
      <h2>Chart: PF vs PA (Scatter)</h2>
      <canvas id="scatterPFPA"></canvas>
    </section>

    <section>
      <h2>Chart: Total PF by Team</h2>
      <canvas id="barPF"></canvas>
    </section>

    <section>
      <h2>Chart: Week Scores</h2>
      <canvas id="barWeek"></canvas>
    </section>
  </div>
</div>

<!-- PREVIEWS -->
<div id="previews" class="view">
  <section>
    <h2>Matchup Previews</h2>
    <div class="muted" style="margin-bottom:8px;">
      Select a week (top left) → “Load Matchups.” Edit or auto-generate previews and click Save. Stored locally. Export/Import to share.
    </div>
    <div class="btnrow" style="margin-bottom:10px;">
      <button id="genAllBtn" class="secondary">Generate All (Local AI)</button>
      <button id="exportBtn" class="secondary">Export JSON</button>
      <input id="importFile" type="file" accept="application/json" style="display:none;">
      <button id="importBtn" class="secondary">Import JSON</button>
    </div>
    <div id="previewsWrap" class="cards"></div>
  </section>
</div>

<!-- ALL-TIME -->
<div id="alltime" class="view">
  <section>
    <h2>All-Time Power Rankings</h2>
    <div class="muted" style="margin-bottom:6px;">Seasons: 2025, 2024, 2023, 2022, 2021 • Weights: Titles 25%, Total PF 25%, Total Wins 25%, Win% 15%, Finals 5%, PF/G 5%</div>
    <div class="btnrow" style="margin-bottom:10px;">
      <button id="refreshAllTimeBtn" class="primary">Compute / Refresh</button>
      <button id="exportAllTimeBtn" class="secondary">Export CSV</button>
    </div>
    <div id="allTimeWrap">—</div>
  </section>

  <section>
    <h2>Rivalries</h2>
    <div class="btnrow" style="margin-bottom:10px;">
      <select id="rivalSelect"></select>
      <button id="refreshRivalsBtn" class="secondary">Refresh Rivalries</button>
    </div>
    <div id="rivalWrap" class="muted">Select a manager to see all-time head-to-head records.</div>
  </section>
</div>

<!-- SEASONS (SUMMARY) -->
<div id="seasons" class="view">
  <section>
    <h2>Past Seasons</h2>

    <!-- Seed UI only appears if auto ESPN fetch fails (e.g., CORS on file://) -->
    <div id="espnSeedRow" class="btnrow" style="display:none; margin-bottom:10px;">
      <input id="espnSeedFile" type="file" accept="application/json" style="display:none;">
      <button id="espnSeedBtn" class="secondary">Seed 2021 (from file)</button>
      <span class="muted">If your browser blocks ESPN, choose the downloaded JSON once. We’ll cache it.</span>
    </div>

    <div class="muted" id="seasonsHint">Includes ESPN 2021 (auto) and Sleeper 2022–2025.</div>
    <div id="seasonsCards" class="cards" style="margin-top:10px;"></div>
  </section>
</div>

<!-- SEASON DETAIL -->
<div id="seasonDetail" class="view">
  <section>
    <h2 id="seasonTitle">Season Detail</h2>
    <div id="seasonMeta" class="muted">—</div>
  </section>
  <section>
    <h2>Standings</h2>
    <div id="seasonStandings"></div>
  </section>
</div>

<script>
/* --- Hardcoded Sleeper league IDs --- */
const LEAGUES = {
  2022: "783723162142658560",
  2023: "921453343510245376",
  2024: "1048189019835740160",
  2025: "1220026837208399872" // current
};
const CURRENT_SEASON = 2025; // dashboard default
const BASE = "https://api.sleeper.app/v1";
const el = (sel) => document.querySelector(sel);

/* DOM refs */
const weekInput = el("#week");
const leagueInfoDiv = el("#leagueInfo"), powerWrap = el("#powerWrap"), standingsWrap = el("#standingsWrap");
const rostersWrap = el("#rostersWrap"), matchupsWrap = el("#matchupsWrap");
const seasonsCards = el("#seasonsCards"), seasonsHint = el("#seasonsHint");
const seasonTitle = el("#seasonTitle"), seasonMeta = el("#seasonMeta"), seasonStandings = el("#seasonStandings");
const previewsWrap = el("#previewsWrap");
const importFile = el("#importFile");
const allTimeWrap = el("#allTimeWrap");
const rivalWrap = el("#rivalWrap"), rivalSelect = el("#rivalSelect");

/* Caches & stores */
let charts = { scatter:null, pf:null, week:null };
let cache = { league:null, users:[], rosters:[], matchupsByWeek:{}, seasons:{}, allMatchups:{} };

/* ==== Profile store (avatars + names) ==== */
const Profiles = new Map(); // user_id -> {name, avatar}
function sleeperAvatarUrl(avatarId){
  if (!avatarId) return null;
  return `https://sleepercdn.com/avatars/thumbs/${avatarId}`;
}
function registerProfilesFromSleeper(users) {
  (users||[]).forEach(u => {
    const id = u.user_id, name = u.display_name || u.username || id;
    const avatar = sleeperAvatarUrl(u.avatar);
    const prev = Profiles.get(id) || {};
    Profiles.set(id, { name: prev.name || name, avatar: avatar || prev.avatar || null });
  });
}
function registerProfilesFromManual(users) {
  (users||[]).forEach(u => {
    const id = u.user_id, name = u.display_name || id;
    const avatar = u.avatar_url || null;
    const prev = Profiles.get(id) || {};
    Profiles.set(id, { name: prev.name || name, avatar: avatar || prev.avatar || null });
  });
}
function initials(str){
  const s=(str||"").trim(); if(!s) return "?";
  const parts = s.split(/\s+/).slice(0,2);
  return parts.map(p=>p[0]).join("").toUpperCase();
}
function esc(s){ return String(s||"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }
function nameCellForOwner(uid, label, small=false){
  const p = Profiles.get(uid) || {};
  const name = label || p.name || uid;
  const av = p.avatar;
  const img = av ? `<img class="${small?'avatar-sm':'avatar'}" src="${av}" alt="">`
                 : `<span class="${small?'avatar-initial-sm':'avatar-initial'}">${esc(initials(name))}</span>`;
  return `<span class="namecell">${img}<span>${esc(name)}</span></span>`;
}

/* ---------- Utilities ---------- */
function themeColors() {
  const s = getComputedStyle(document.documentElement);
  return { text: s.getPropertyValue('--text').trim(), grid: s.getPropertyValue('--border').trim(),
           accent: s.getPropertyValue('--accent').trim(), cyan: s.getPropertyValue('--accent-2').trim() };
}
function setActive(tab) {
  document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
  document.querySelectorAll('.tabbtn').forEach(b => b.classList.remove('active'));
  el("#"+tab).classList.add('active');
  document.querySelector(`.tabbtn[data-tab="${tab}"]`)?.classList.add('active');
  if (tab === 'alltime') { ensureRivalriesComputed().catch(()=>{}); }
}
document.querySelectorAll('.tabbtn').forEach(b => b.addEventListener('click', () => setActive(b.dataset.tab)));

async function fetchJson(path) {
  const url = `${BASE}${path}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
  return res.json();
}
function table(headers, rows) {
  const th = headers.map(h => `<th>${h}</th>`).join("");
  const tr = rows.map(r => `<tr>${r.map(c => `<td>${c ?? ""}</td>`).join("")}</tr>`).join("");
  return `<div style="overflow:auto; max-height:60vh"><table><thead><tr>${th}</tr></thead><tbody>${tr}</tbody></table></div>`;
}
function destroyChart(ref) { if (ref && typeof ref.destroy === "function") ref.destroy(); }

/* ---------- Charts ---------- */
function renderPFPAChart(rosters, userMap) {
  destroyChart(charts.scatter);
  const c = themeColors();
  const data = rosters.map(r => ({
    x: r?.settings?.fpts_against ?? 0,
    y: r?.settings?.fpts ?? 0,
    label: r?.settings?.team_name || userMap[r.owner_id] || `Roster ${r.roster_id}`
  }));
  charts.scatter = new Chart(el("#scatterPFPA"), {
    type: "scatter",
    data: { datasets: [{ label:"PF vs PA", data, parsing:false, pointRadius:5, backgroundColor:c.accent }] },
    options: {
      maintainAspectRatio:false,
      scales: {
        x: { title:{display:true, text:"Points Against (PA)", color:c.text}, grid:{color:c.grid}, ticks:{color:c.text} },
        y: { title:{display:true, text:"Points For (PF)", color:c.text}, grid:{color:c.grid}, ticks:{color:c.text} }
      },
      plugins: { legend: { labels:{ color:c.text } } }
    }
  });
}
function renderPFBar(rosters, userMap) {
  destroyChart(charts.pf);
  const c = themeColors();
  const labels = rosters.map(r => r?.settings?.team_name || userMap[r.owner_id] || `Roster ${r.roster_id}`);
  const pf = rosters.map(r => r?.settings?.fpts ?? 0);
  charts.pf = new Chart(el("#barPF"), {
    type: "bar",
    data: { labels, datasets: [{ label:"Total PF", data: pf, backgroundColor:c.accent }] },
    options: {
      maintainAspectRatio:false,
      plugins:{ legend:{ labels:{ color:c.text } } },
      scales:{ x:{ ticks:{ color:c.text }, grid:{ color:c.grid } }, y:{ ticks:{ color:c.text }, grid:{ color:c.grid }, title:{display:true, text:"Points", color:c.text} } }
    }
  });
}
function renderWeekBar(rows) {
  destroyChart(charts.week);
  const c = themeColors();
  const labels = rows.flatMap(r => [r[2].replace(/<[^>]+>/g,''), r[4].replace(/<[^>]+>/g,'')]);
  const scores = rows.flatMap(r => [Number(r[3])||0, Number(r[5])||0]);
  if (!labels.length) { charts.week = null; el("#barWeek").replaceWith(el("#barWeek").cloneNode(true)); return; }
  charts.week = new Chart(el("#barWeek"), {
    type: "bar",
    data: { labels, datasets: [{ label:"Week Scores", data: scores, backgroundColor: labels.map((_,i)=> i%2===0 ? c.cyan : c.accent) }] },
    options: {
      maintainAspectRatio:false,
      plugins:{ legend:{ labels:{ color:c.text } } },
      scales:{ x:{ ticks:{ color:c.text }, grid:{ color:c.grid } }, y:{ ticks:{ color:c.text }, grid:{ color:c.grid }, title:{display:true, text:"Points", color:c.text} } }
    }
  });
}

/* ---------- Auto-detect current NFL week ---------- */
async function getCurrentWeek() {
  el("#seasonNote").lastElementChild.textContent = "Detecting current NFL week…";
  try {
    const state = await fetchJson("/state/nfl");
    if (state.season_type === "regular" && Number(state.week)) {
      weekInput.value = Number(state.week);
      el("#seasonNote").lastElementChild.textContent = `Week ${state.week} • ${state.season}`;
    } else {
      weekInput.value = 1;
      el("#seasonNote").lastElementChild.textContent = `${state.season_type || "offseason"} • defaulting to Week 1`;
    }
  } catch { el("#seasonNote").lastElementChild.textContent = "Couldn’t detect week (set manually)."; }
}

/* ---------- Power Rankings (current season) ---------- */
function normalize(arr) {
  const min = Math.min(...arr), max = Math.max(...arr);
  if (!isFinite(min) || !isFinite(max) || min === max) return arr.map(_ => 0.5);
  return arr.map(v => (v - min) / (max - min));
}
async function computePower(leagueId, rosters, recentWindow = 3, currentWeek = Number(weekInput.value || 1)) {
  const teamIndex = new Map(); rosters.forEach((r, i) => teamIndex.set(String(r.roster_id), i));

  const gamesPlayed = rosters.map(r => (r?.settings?.wins ?? 0) + (r?.settings?.losses ?? 0));
  const wins = rosters.map(r => (r?.settings?.wins ?? 0));
  const pf = rosters.map(r => (r?.settings?.fpts ?? 0));

  const recentPFperTeam = new Array(rosters.length).fill(0);
  const recentGames = new Array(rosters.length).fill(0);
  const movTotals = new Array(rosters.length).fill(0);
  const movWins = new Array(rosters.length).fill(0);

  const startWeek = Math.max(1, currentWeek - recentWindow + 1);
  for (let wk = startWeek; wk <= currentWeek; wk++) {
    try {
      const m = await fetchJson(`/league/${leagueId}/matchups/${wk}`);
      const groups = {};
      m.forEach(x => { const id = x.matchup_id ?? `solo-${x.roster_id}`; (groups[id] ||= []).push(x); });
      Object.values(groups).forEach(([a, b]) => {
        if (!a || !b) return;
        const ia = teamIndex.get(String(a.roster_id));
        the_ib = teamIndex.get(String(b.roster_id));
        const ib = the_ib;
        if (ia == null || ib == null) return;
        recentPFperTeam[ia] += (a.points ?? 0);
        recentPFperTeam[ib] += (b.points ?? 0);
        recentGames[ia]++; recentGames[ib]++;
        const diff = (a.points ?? 0) - (b.points ?? 0);
        if (diff > 0) { movTotals[ia] += diff; movWins[ia]++; }
        else if (diff < 0) { movTotals[ib] += (-diff); movWins[ib]++; }
      });
    } catch {}
  }

  const recentPFpg = recentPFperTeam.map((sum, i) => recentGames[i] ? (sum / recentGames[i]) : 0);
  const movAvg = movTotals.map((sum, i) => movWins[i] ? (sum / movWins[i]) : 0);

  const PF_Score = normalize(pf);
  const Wins_Score = wins.map((w, i) => (gamesPlayed[i] ? (w / gamesPlayed[i]) : 0));
  const MOV_Score = normalize(movAvg);
  const Recent_Score = normalize(recentPFpg);

  const weights = { PF: 0.55, W: 0.25, MOV: 0.10, RECENT: 0.10 };
  const PowerScore = rosters.map((_, i) =>
    weights.PF * PF_Score[i] +
    weights.W  * Wins_Score[i] +
    weights.MOV* MOV_Score[i] +
    weights.RECENT * Recent_Score[i]
  );

  return { PowerScore, recentPFpg };
}
async function buildStandingsWithPower(leagueId, users, rosters) {
  const { PowerScore } = await computePower(leagueId, rosters, 3, Number(weekInput.value || 1));
  const userMap = {}; users.forEach(u => userMap[u.user_id] = u.display_name);

  const rows = rosters
    .map((r, i) => ({
      team: r?.settings?.team_name || userMap[r.owner_id] || `Roster ${r.roster_id}`,
      wins: r?.settings?.wins ?? 0,
      losses: r?.settings?.losses ?? 0,
      pf: r?.settings?.fpts ?? 0,
      pa: r?.settings?.fpts_against ?? 0,
      pwr: PowerScore[i],
      owner: r.owner_id
    }))
    .sort((a,b) => b.pwr - a.pwr)
    .map((x, rank) => [rank + 1, nameCellForOwner(x.owner, x.team), x.wins, x.losses, x.pf, x.pa, (x.pwr*100).toFixed(1)]);

  return table(["PWR Rank","Team","W","L","PF","PA","PowerScore"], rows);
}

/* ---------- Classic Standings (Wins → PF) ---------- */
function buildClassicStandings(users, rosters) {
  const userMap = {}; users.forEach(u => userMap[u.user_id] = u.display_name);
  const sorted = [...rosters].sort((a,b) =>
    (b?.settings?.wins ?? 0) - (a?.settings?.wins ?? 0) ||
    (b?.settings?.fpts ?? 0) - (a?.settings?.fpts ?? 0)
  );

  const rows = sorted.map((r, i) => {
    const wins = r?.settings?.wins ?? 0;
    const losses = r?.settings?.losses ?? 0;
    const pf = r?.settings?.fpts ?? 0;
    const pa = r?.settings?.fpts_against ?? 0;
    const games = Math.max(1, wins + losses);
    const name = r?.settings?.team_name || userMap[r.owner_id] || `Roster ${r.roster_id}`;
    return [
      i+1,
      nameCellForOwner(r.owner_id, name),
      wins, losses, pf, pa, (pf / games).toFixed(2)
    ];
  });

  return table(["Rank","Team","W","L","PF","PA","Avg PF/G"], rows);
}

/* ---------- Seasons summary & detail ---------- */
function teamsFromMatch(m) { return [m.roster_id_1 ?? m.team1 ?? m.t1 ?? null, m.roster_id_2 ?? m.team2 ?? m.t2 ?? null]; }
function pointsFromMatch(m) { return [m.t1_points ?? m.points1 ?? m.score1 ?? null, m.t2_points ?? m.points2 ?? m.score2 ?? null]; }
function winnerFromMatch(m) {
  const wf = ['winner_roster_id','w','winner'].find(k => k in m); if (wf && m[wf] != null) return m[wf];
  const [t1,t2] = teamsFromMatch(m), [p1,p2] = pointsFromMatch(m);
  if (t1 != null && t2 != null && p1 != null && p2 != null) return Number(p1) === Number(p2) ? t1 : (Number(p1) > Number(p2) ? t1 : t2);
  return null;
}
function podiumFromBracket(bracket) {
  if (!Array.isArray(bracket) || bracket.length === 0) return { champion:null, runnerUp:null, third:null };
  const rKey = ['round','r','bracket_round','matchupPeriodId'].find(k => bracket.some(x => k in x)) || 'round';
  const maxRound = Math.max(...bracket.map(m => Number(m[rKey] ?? 0)));
  const finals = bracket.filter(m => Number(m[rKey] ?? 0) === maxRound);

  const getTeams = m => [m.roster_id_1 ?? m.team1 ?? m.t1 ?? null, m.roster_id_2 ?? m.team2 ?? m.t2 ?? null];
  const getPoints = m => [m.t1_points ?? m.points1 ?? m.score1 ?? null, m.t2_points ?? m.points2 ?? m.score2 ?? null];
  const explicitWinner = m => m.winner_roster_id ?? m.w ?? m.winner ?? null;

  let f = finals.find(m => getTeams(m).every(Boolean) && (explicitWinner(m) != null || getPoints(m).every(v => v != null))) || finals[0];
  if (!f) return { champion:null, runnerUp:null, third:null };

  let champ = explicitWinner(f);
  if (champ == null) {
    const [p1,p2] = getPoints(f).map(Number);
    const [t1,t2] = getTeams(f);
    if (p1 != null && p2 != null && t1 != null && t2 != null) {
      champ = (p1 >= p2) ? t1 : t2;
    }
  }
  const [t1,t2] = getTeams(f);
  const runner = (champ != null && t1 != null && t2 != null) ? (String(champ) === String(t1) ? t2 : t1) : null;

  let third = null;
  const other = finals.find(x => x !== f && getTeams(x).every(Boolean));
  if (other) {
    const ew = explicitWinner(other);
    if (ew != null) third = ew;
    else {
      const [op1,op2] = getPoints(other).map(Number);
      const [ot1,ot2] = getTeams(other);
      if (op1 != null && op2 != null && ot1 != null && ot2 != null) {
        third = (op1 >= op2) ? ot1 : ot2;
      }
    }
  }
  return { champion: champ ?? null, runnerUp: runner ?? null, third };
}
function rosterNameFromId(rosters, users, rosterId) {
  const userMap = {}; users.forEach(u => userMap[u.user_id] = u.display_name);
  const r = rosters.find(x => String(x.roster_id) === String(rosterId));
  return r ? (r?.settings?.team_name || userMap[r.owner_id] || `Roster ${r.roster_id}`) : null;
}
async function fetchLeagueBundleSleeper(leagueId){
  const league = await fetchJson(`/league/${leagueId}`);
  const [users, rosters] = await Promise.all([
    fetchJson(`/league/${leagueId}/users`),
    fetchJson(`/league/${leagueId}/rosters`)
  ]);
  registerProfilesFromSleeper(users);
  let podium = { champion:null, runnerUp:null, third:null };
  try {
    const wb = await fetchJson(`/league/${leagueId}/winners_bracket`);
    podium = podiumFromBracket(wb);
  } catch {}
  return { league, users, rosters, podium };
}
async function fetchLeagueBundle(leagueId) { return fetchLeagueBundleSleeper(leagueId); }
async function summarizeLeagueById(leagueId) {
  const { league, users, rosters, podium } = await fetchLeagueBundle(leagueId);
  const userMap = {}; users.forEach(u => userMap[u.user_id] = u.display_name);

  const sorted = [...rosters].sort((a,b) => (b?.settings?.wins ?? 0) - (a?.settings?.wins ?? 0) || (b?.settings?.fpts ?? 0) - (a?.settings?.fpts ?? 0));
  const best = sorted[0];
  const pfLeader = [...rosters].sort((a,b)=> (b?.settings?.fpts ?? 0) - (a?.settings?.fpts ?? 0))[0];

  function rosterNameFromIdLocal(rosterId){
    const r = rosters.find(x=> String(x.roster_id)===String(rosterId));
    return r ? (r?.settings?.team_name || userMap[r.owner_id] || `Roster ${r.roster_id}`) : null;
  }

  return {
    season: league.season,
    leagueName: league.name || "League",
    teamCount: league.total_rosters ?? users.length,
    bestRecord: best ? `${best?.settings?.wins ?? 0}-${best?.settings?.losses ?? 0}` : "—",
    bestName: best ? (best?.settings?.team_name || userMap[best.owner_id] || `Roster ${best.roster_id}`) : "—",
    pfLeader: pfLeader ? (pfLeader?.settings?.team_name || userMap[pfLeader.owner_id] || `Roster ${pfLeader.roster_id}`) : "—",
    pf: pfLeader?.settings?.fpts ?? 0,
    champion: podium.champion != null ? rosterNameFromIdLocal(podium.champion) : "—",
    runnerUp: podium.runnerUp != null ? rosterNameFromIdLocal(podium.runnerUp) : "—",
    third: podium.third != null ? rosterNameFromIdLocal(podium.third) : "—",
    leagueId,
    championOwner: (podium.champion != null) ? rosters.find(r=>r.roster_id===podium.champion)?.owner_id : null,
    runnerOwner: (podium.runnerUp != null) ? rosters.find(r=>r.roster_id===podium.runnerUp)?.owner_id : null,
    thirdOwner: (podium.third != null) ? rosters.find(r=>r.roster_id===podium.third)?.owner_id : null
  };
}
async function loadSeasonsSummary() {
  try {
    seasonsHint.textContent = "Loading seasons…";
    const years = [2025, 2024, 2023, 2022, 2021];
    const summaries = [];
    for (const yr of years) {
      const id = LEAGUES[yr] || (MANUAL[manualKey(yr)] ? manualKey(yr) : null);
      if (!id) continue;
      const s = await summarizeLeagueById(id);
      summaries.push(s);
    }

    seasonsCards.innerHTML = summaries.map(s => `
      <div class="card">
        <h3>${s.season}</h3>
        <div class="kv"><span>Teams</span><span>${s.teamCount}</span></div>
        <div class="kv"><span>Best Record</span><span>${s.bestRecord}</span></div>
        <div class="kv"><span>Regular-season leader</span><span>${esc(s.bestName)}</span></div>
        <div class="kv"><span>PF leader</span><span>${esc(s.pfLeader)} (${s.pf})</span></div>
        <div class="kv"><span>Champion</span><span>${s.championOwner ? nameCellForOwner(s.championOwner, s.champion, true) : esc(s.champion)}</span></div>
        <div class="kv"><span>Runner-up</span><span>${s.runnerOwner ? nameCellForOwner(s.runnerOwner, s.runnerUp, true) : esc(s.runnerUp)}</span></div>
        <div class="kv"><span>Third</span><span>${s.thirdOwner ? nameCellForOwner(s.thirdOwner, s.third, true) : esc(s.third)}</span></div>
        <div style="margin-top:8px">
          <span class="link" data-league="${s.leagueId}">Open season →</span>
        </div>
      </div>
    `).join("");

    seasonsCards.querySelectorAll('.link').forEach(a => {
      a.addEventListener('click', () => openSeasonDetail(a.dataset.league));
    });

    seasonsHint.textContent = `Loaded ${summaries.length} season(s). Click a card to view details.`;
  } catch (e) { seasonsHint.textContent = `Couldn’t load seasons: ${e.message}`; }
}
async function openSeasonDetail(leagueId) {
  try {
    setActive('seasonDetail');
    seasonTitle.textContent = `Season ${leagueId}`;
    const { league, users, rosters, podium } = await fetchLeagueBundle(leagueId);
    registerProfilesFromSleeper(users);
    seasonTitle.textContent = `Season ${league.season}`;

    const userMap = {}; users.forEach(u => userMap[u.user_id] = u.display_name);

    const rosterToOwner = {}; rosters.forEach(r => rosterToOwner[r.roster_id] = r.owner_id);
    const champ = podium.champion != null ? rosterNameFromId(rosters, users, podium.champion) : "—";
    const runner = podium.runnerUp != null ? rosterNameFromId(rosters, users, podium.runnerUp) : "—";
    const third = podium.third != null ? rosterNameFromId(rosters, users, podium.third) : "—";

    seasonMeta.innerHTML = `
      <span class="pill">${league.name || "League"}</span>
      <span class="muted"> • Rosters: ${league.total_rosters ?? users.length}</span>
      <span class="muted"> • ID: ${leagueId}</span>
      <span class="muted"> • Champion: ${podium.champion ? nameCellForOwner(rosterToOwner[podium.champion], champ, true) : esc(champ)} • Runner-up: ${podium.runnerUp ? nameCellForOwner(rosterToOwner[podium.runnerUp], runner, true) : esc(runner)} • Third: ${podium.third ? nameCellForOwner(rosterToOwner[podium.third], third, true) : esc(third)}</span>
    `;

    const sorted = [...rosters].sort((a,b) => (b?.settings?.wins ?? 0) - (a?.settings?.wins ?? 0) || (b?.settings?.fpts ?? 0) - (a?.settings?.fpts ?? 0));
    const rows = sorted.map((r, i) => [
      i+1,
      nameCellForOwner(r.owner_id, r?.settings?.team_name || userMap[r.owner_id] || `Roster ${r.roster_id}`),
      r?.settings?.wins ?? 0,
      r?.settings?.losses ?? 0,
      r?.settings?.fpts ?? 0,
      r?.settings?.fpts_against ?? 0,
      ((r?.settings?.fpts ?? 0) / Math.max(1, (r?.settings?.wins ?? 0) + (r?.settings?.losses ?? 0))).toFixed(2)
    ]);
    seasonStandings.innerHTML = table(["Rank","Team","W","L","PF","PA","Avg PF/G"], rows);
  } catch (e) {
    seasonMeta.textContent = `Error loading season: ${e.message}`;
    seasonStandings.innerHTML = "";
  }
}

/* ---------- Current (2025) league → dashboard ---------- */
async function loadCurrentLeague() {
  try {
    setActive('dashboard');
    matchupsWrap.textContent = "—";
    const leagueId = LEAGUES[CURRENT_SEASON];

    const [league, users, rosters] = await Promise.all([
      fetchJson(`/league/${leagueId}`),
      fetchJson(`/league/${leagueId}/users`),
      fetchJson(`/league/${leagueId}/rosters`)
    ]);
    cache = { ...cache, league, users, rosters };
    registerProfilesFromSleeper(users);

    const userMap = {}; users.forEach(u => userMap[u.user_id] = u.display_name);

    leagueInfoDiv.innerHTML = `
      <div style="font-weight:700; font-size:16px;">${league.name || "(unnamed league)"} <span class="muted">(${league.season})</span></div>
      <div class="muted">Rosters: ${league.total_rosters ?? "?"} • Scoring: ${league.scoring_settings ? "Custom" : "Standard"} • <span class="pill">ID: ${leagueId}</span></div>
    `;

    powerWrap.innerHTML = await buildStandingsWithPower(leagueId, users, rosters);
    standingsWrap.innerHTML = buildClassicStandings(users, rosters);

    const rosterRows = rosters.map(r => [
      r.roster_id,
      nameCellForOwner(r.owner_id, userMap[r.owner_id] || ""),
      r?.settings?.team_name || "",
      r?.settings?.wins ?? 0,
      r?.settings?.losses ?? 0,
      r?.settings?.fpts ?? 0,
      r?.settings?.fpts_against ?? 0,
      r?.metadata?.streak || ""
    ]);
    rostersWrap.innerHTML = table(["Roster ID","Owner","Team Name","W","L","PF","PA","Streak"], rosterRows);

    renderPFPAChart(rosters, userMap);
    renderPFBar(rosters, userMap);

    loadSeasonsSummary().catch(()=>{});

  } catch (err) {
    leagueInfoDiv.textContent = `Error: ${err.message}`;
    powerWrap.textContent = ""; standingsWrap.textContent = ""; rostersWrap.textContent = "";
    destroyChart(charts.scatter); destroyChart(charts.pf);
  }
}

/* ---------- Week matchups (current season) ---------- */
async function loadMatchups() {
  try {
    const leagueId = LEAGUES[CURRENT_SEASON];
    const week = Number(weekInput.value);
    if (!week || week < 1 || week > 18) throw new Error("Week must be 1–18.");

    const [matchups, rosters, users] = await Promise.all([
      fetchJson(`/league/${leagueId}/matchups/${week}`),
      cache.rosters?.length ? Promise.resolve(cache.rosters) : fetchJson(`/league/${leagueId}/rosters`),
      cache.users?.length ? Promise.resolve(cache.users) : fetchJson(`/league/${leagueId}/users`)
    ]);

    cache.matchupsByWeek[week] = matchups;
    registerProfilesFromSleeper(users);

    const userMap = {}; users.forEach(u => userMap[u.user_id] = u.display_name);
    const rosterToOwner = {}; rosters.forEach(r => rosterToOwner[r.roster_id] = r.owner_id);

    const groups = {};
    matchups.forEach(m => { const id = m.matchup_id ?? `solo-${m.roster_id}`; (groups[id] ||= []).push(m); });

    const rows = Object.entries(groups).map(([mid, arr]) => {
      if (arr.length === 2) {
        const [a,b] = arr;
        const ownerA = rosterToOwner[a.roster_id], ownerB = rosterToOwner[b.roster_id];
        const nameA = rosters.find(r=>r.roster_id===a.roster_id)?.settings?.team_name || userMap[ownerA] || `Roster ${a.roster_id}`;
        const nameB = rosters.find(r=>r.roster_id===b.roster_id)?.settings?.team_name || userMap[ownerB] || `Roster ${b.roster_id}`;
        const scoreA = a.points ?? 0, scoreB = b.points ?? 0;
        const winner = scoreA === scoreB ? "Tie" : (scoreA > scoreB ? nameA : nameB);
        return [week, mid, nameCellForOwner(ownerA, nameA), scoreA, nameCellForOwner(ownerB, nameB), scoreB, esc(winner)];
      } else {
        const only = arr[0];
        const owner = rosterToOwner[only.roster_id];
        const name = rosters.find(r=>r.roster_id===only.roster_id)?.settings?.team_name || userMap[owner] || `Roster ${only.roster_id}`;
        return [week, mid, nameCellForOwner(owner, name), (only.points ?? 0), "(bye)", "", esc(name)];
      }
    }).sort((a,b)=> (b[3]+(b[5]||0)) - (a[3]+(a[5]||0)));

    matchupsWrap.innerHTML = rows.length
      ? table(["Week","Matchup ID","Team A","Score A","Team B","Score B","Winner"], rows)
      : `<div class="muted">No matchups found for week ${week}.</div>`;

    renderWeekBar(rows);

    renderPreviews(week, groups, users, rosters);

  } catch (err) {
    matchupsWrap.textContent = `Error: ${err.message}`;
    destroyChart(charts.week);
  }
}

/* ---------- Previews: storage + generator + import/export ---------- */
function previewKey(week, matchupId) {
  const leagueId = LEAGUES[CURRENT_SEASON];
  return `sleeper_previews_${leagueId}_${week}_${matchupId}`;
}
function loadPreview(week, matchupId) { return localStorage.getItem(previewKey(week, matchupId)) || ""; }
function savePreview(week, matchupId, text) { localStorage.setItem(previewKey(week, matchupId), text || ""); }

async function generatePreviewLocal({ week, a, b, teamNameA, teamNameB, rosters, users }) {
  const leagueId = LEAGUES[CURRENT_SEASON];
  const { PowerScore, recentPFpg } = await computePower(leagueId, rosters, 3, Number(weekInput.value || week || 1));

  const idxByRoster = new Map(); rosters.forEach((r,i)=> idxByRoster.set(String(r.roster_id), i));
  const ia = idxByRoster.get(String(a.roster_id));
  const ib = idxByRoster.get(String(b.roster_id));

  const wins = r => r?.settings?.wins ?? 0;
  const losses = r => r?.settings?.losses ?? 0;
  const pf = r => r?.settings?.fpts ?? 0;
  const pa = r => r?.settings?.fpts_against ?? 0;

  const pwrA = ia != null ? PowerScore[ia] : 0.5;
  const pwrB = ib != null ? PowerScore[ib] : 0.5;
  const prA = (pwrA * 100).toFixed(1), prB = (pwrB * 100).toFixed(1);
  const recA = ia != null ? recentPFpg[ia] : 0;
  const recB = ib != null ? recentPFpg[ib] : 0;

  const edge = (pwrA - pwrB);
  const fave = edge >= 0 ? teamNameA : teamNameB;
  const conf  = Math.min(12, Math.max(3, Math.round(Math.abs(edge) * 14)));

  const gpA = Math.max(1, wins(a)+losses(a)), gpB = Math.max(1, wins(b)+losses(b));
  const pfpgA = pf(a)/gpA, pfpgB = pf(b)/gpB;
  const projA = Math.round((pfpgA*0.7 + recA*0.3));
  const projB = Math.round((pfpgB*0.7 + recB*0.3));
  const proj = `${fave} ${Math.max(projA, projB)}–${Math.min(projA, projB)}`;

  const streak = r => (r?.metadata?.streak || "").replace(/_/g,' ');
  const txt = `
**Week ${week} Preview: ${teamNameA} vs ${teamNameB}**

${teamNameA}: ${wins(a)}-${losses(a)} (PF ${pf(a)}, PA ${pa(a)}), PowerScore ${prA}. ${streak(a) ? `Streak: ${streak(a)}.` : "" }
${teamNameB}: ${wins(b)}-${losses(b)} (PF ${pf(b)}, PA ${pa(b)}), PowerScore ${prB}. ${streak(b) ? `Streak: ${streak(b)}.` : "" }

**Edge:** ${fave} by model (confidence ${conf}/12). Recent form favors ${(recA >= recB) ? teamNameA : teamNameB}.

**X-factors:** 
- Efficiency: ${teamNameA} ${pfpgA.toFixed(1)} PF/G vs ${teamNameB} ${pfpgB.toFixed(1)} PF/G.
- Recent scoring: ${teamNameA} ${recA.toFixed(1)} vs ${teamNameB} ${recB.toFixed(1)} (last 3).
- Schedule luck matters—but scoring power drives the projection.

**Pick:** ${proj}
`.trim();
  return txt;
}
function renderPreviews(week, groups, users, rosters) {
  const userMap = {}; users.forEach(u => userMap[u.user_id] = u.display_name);
  const nameOfRoster = (rid) => {
    const r = rosters.find(x => x.roster_id === rid) || {};
    return r?.settings?.team_name || userMap[r.owner_id] || `Roster ${rid}`;
  };
  const ownerOfRoster = (rid) => (rosters.find(x=>x.roster_id===rid)||{}).owner_id;

  const cards = Object.entries(groups).map(([mid, arr]) => {
    if (arr.length !== 2) return '';
    const [a,b] = arr;
    const saved = loadPreview(week, mid);
    const ownerA = ownerOfRoster(a.roster_id), ownerB = ownerOfRoster(b.roster_id);

    return `
      <div class="card preview-card" data-mid="${mid}">
        <h3>
          <span class="namecell">${nameCellForOwner(ownerA, nameOfRoster(a.roster_id), true)}</span>
          <span class="muted"> vs </span>
          <span class="namecell">${nameCellForOwner(ownerB, nameOfRoster(b.roster_id), true)}</span>
          <span class="muted"> • Week ${week}</span>
        </h3>
        <div class="preview-meta">
          <span class="pill">Matchup ID: ${mid}</span>
          <span>Team A PF: ${rosters.find(r=>r.roster_id===a.roster_id)?.settings?.fpts ?? 0}</span>
          <span>Team B PF: ${rosters.find(r=>r.roster_id===b.roster_id)?.settings?.fpts ?? 0}</span>
        </div>
        <textarea class="preview" placeholder="Write your preview...">${saved}</textarea>
        <div class="btnrow">
          <button class="secondary genOneBtn">Auto-fill (Local AI)</button>
          <button class="primary saveBtn">Save</button>
        </div>
      </div>
    `;
  }).filter(Boolean);

  previewsWrap.innerHTML = cards.join("");
  previewsWrap.querySelectorAll('.preview-card').forEach(card => {
    const mid = card.dataset.mid;
    const genBtn = card.querySelector('.genOneBtn');
    const saveBtn = card.querySelector('.saveBtn');
    const ta = card.querySelector('textarea.preview');

    genBtn.addEventListener('click', async () => {
      const arr = (function(){ return groups[mid]; })();
      if (!arr || arr.length !== 2) return;
      const [a,b] = arr;
      ta.value = "Generating…";
      try {
        ta.value = await generatePreviewLocal({
          week,
          a, b,
          teamNameA: (rosters.find(r=>r.roster_id===a.roster_id)?.settings?.team_name) || "Team A",
          teamNameB: (rosters.find(r=>r.roster_id===b.roster_id)?.settings?.team_name) || "Team B",
          rosters, users
        });
      } catch (e) { ta.value = `Could not generate: ${e.message}`; }
    });

    saveBtn.addEventListener('click', () => {
      savePreview(week, mid, ta.value);
      saveBtn.textContent = "Saved ✓";
      setTimeout(()=> saveBtn.textContent = "Save", 1200);
    });
  });
}
// Export/Import previews JSON
el("#exportBtn").addEventListener("click", () => {
  const leagueId = LEAGUES[CURRENT_SEASON];
  const prefix = `sleeper_previews_${leagueId}_`;
  const obj = {};
  for (let i=0; i<localStorage.length; i++){
    const k = localStorage.key(i);
    if (k.startsWith(prefix)) {
      const parts = k.slice(prefix.length).split("_");
      const week = parts[0], mid = parts.slice(1).join("_");
      obj[week] ||= {};
      obj[week][mid] = localStorage.getItem(k);
    }
  }
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href = url; a.download = "previews.json"; a.click(); URL.revokeObjectURL(url);
});
el("#importBtn").addEventListener("click", () => importFile.click());
importFile.addEventListener("change", async (e) => {
  const f = e.target.files?.[0]; if (!f) return;
  const txt = await f.text();
  try {
    const data = JSON.parse(txt);
    const leagueId = LEAGUES[CURRENT_SEASON];
    Object.entries(data).forEach(([week, m]) => {
      Object.entries(m).forEach(([mid, text]) => {
        localStorage.setItem(`sleeper_previews_${leagueId}_${week}_${mid}`, text || "");
      });
    });
    alert("Previews imported.");
  } catch (err) { alert("Invalid JSON: "+err.message); }
});

/* ---------- ALL-TIME RANKINGS ---------- */
function csvEscape(v){ if (v==null) return ""; const s=String(v); return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s; }
function downloadCSV(filename, rows, headers){
  const csv = [headers.join(",")].concat(rows.map(r=> r.map(csvEscape).join(","))).join("\n");
  const blob = new Blob([csv], {type:"text/csv"}); const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href=url; a.download=filename; a.click(); URL.revokeObjectURL(url);
}
async function computeAllTime() {
  const years = [2025, 2024, 2023, 2022, 2021];
  const agg = {};
  const nameSeen = {};

  function addUser(uid, display) {
    if (!agg[uid]) agg[uid] = { user_id: uid, display: display || uid, seasons: 0, wins:0, losses:0, pf:0, titles:0, finals:0, thirds:0 };
  }

  for (const yr of years) {
    const lid = LEAGUES[yr] || (MANUAL[manualKey(yr)] ? manualKey(yr) : null);
    if (!lid) continue;
    const { users, rosters, podium } = await fetchLeagueBundle(lid);

    const userMap = {}; (users||[]).forEach(u => userMap[u.user_id] = u.display_name || u.username || u.user_id);
    const rosterToOwner = {}; (rosters||[]).forEach(r => rosterToOwner[r.roster_id] = r.owner_id);

    (rosters||[]).forEach(r => {
      const uid = r.owner_id; if (!uid) return;
      const wins = r?.settings?.wins ?? 0;
      const losses = r?.settings?.losses ?? 0;
      const pf = r?.settings?.fpts ?? 0;

      addUser(uid, userMap[uid]);
      nameSeen[uid] = r?.settings?.team_name || userMap[uid] || `Manager ${uid}`;
      agg[uid].seasons += 1;
      agg[uid].wins += wins;
      agg[uid].losses += losses;
      agg[uid].pf += pf;
    });

    const champion = podium?.champion != null ? rosterToOwner[podium.champion] : null;
    const runner   = podium?.runnerUp != null ? rosterToOwner[podium.runnerUp] : null;
    const third    = podium?.third != null ? rosterToOwner[podium.third] : null;
    if (champion && agg[champion]) agg[champion].titles += 1;
    if (runner && agg[runner]) agg[runner].finals += 1;
    if (third && agg[third]) agg[third].thirds += 1;
  }

  const arr = Object.values(agg).map(a => {
    const games = Math.max(1, a.wins + a.losses);
    return { ...a, name: nameSeen[a.user_id] || a.display, winpct: (a.wins / games), pfpg: (a.pf / games) };
  });

  const vec = (key) => arr.map(x => x[key] ?? 0);
  const normalize = (xs) => { const min=Math.min(...xs), max=Math.max(...xs); if (!isFinite(min) || !isFinite(max) || min===max) return xs.map(_=>0.5); return xs.map(v=>(v-min)/(max-min)); };
  const nWins = normalize(vec('wins'));
  const nPF   = normalize(vec('pf'));
  const nWinP = normalize(vec('winpct'));
  const nPFPG = normalize(vec('pfpg'));
  const nTit  = normalize(vec('titles'));
  const nFin  = normalize(vec('finals'));
  const W = { TITLES:0.25, PF:0.25, WINS:0.25, WINP:0.15, FINALS:0.05, PFPG:0.05 };

  arr.forEach((x,i) => {
    x.score = W.TITLES*nTit[i] + W.PF*nPF[i] + W.WINS*nWins[i] + W.WINP*nWinP[i] + W.FINALS*nFin[i] + W.PFPG*nPFPG[i];
  });

  arr.sort((a,b)=> b.score - a.score);
  return arr;
}
function renderAllTimeTable(data) {
  const rows = data.map((x, idx) => [
    idx+1,
    nameCellForOwner(x.user_id, x.name),
    x.seasons,
    x.titles,
    x.finals,
    x.wins,
    x.losses,
    (x.winpct*100).toFixed(1)+"%",
    Math.round(x.pf),
    x.pfpg.toFixed(1),
    (x.score*100).toFixed(1)
  ]);
  allTimeWrap.innerHTML = table(
    ["Rank","Manager / Team","Seasons","Titles","Finals","Wins","Losses","Win%","Total PF","PF/G","All-Time Score"],
    rows
  );

  el("#exportAllTimeBtn").onclick = () => {
    const plainRows = data.map((x, idx) => [
      idx+1, x.name, x.seasons, x.titles, x.finals, x.wins, x.losses, (x.winpct*100).toFixed(1)+"%", Math.round(x.pf), x.pfpg.toFixed(1), (x.score*100).toFixed(1)
    ]);
    downloadCSV("all_time_power.csv", plainRows, ["Rank","Manager/Team","Seasons","Titles","Finals","Wins","Losses","Win%","Total PF","PF/G","All-Time Score"]);
  };
}

/* ---------- Rivalries (head-to-head across seasons) ---------- */
let Rivalries = null; // { pairs: Map("uidA|uidB" -> {a:uidA,b:uidB, games:[{a_uid,b_uid,a_pts,b_pts,season,week}] }), users:Set(uid) }
function pairKey(a,b){ return [String(a),String(b)].sort().join("|"); }
async function fetchSeasonMatchupsAllWeeks(leagueId, rosters){
  const result = [];
  const teamIndex = new Map(); rosters.forEach(r => teamIndex.set(r.roster_id, r.owner_id));
  for (let wk=1; wk<=18; wk++){
    try {
      const arr = await fetchJson(`/league/${leagueId}/matchups/${wk}`);
      const groups = {};
      arr.forEach(x => { const id = x.matchup_id ?? `solo-${x.roster_id}`; (groups[id] ||= []).push(x); });
      Object.values(groups).forEach(g => {
        if (g.length !== 2) return;
        const [a,b] = g;
        const a_uid = teamIndex.get(a.roster_id), b_uid = teamIndex.get(b.roster_id);
        if (!a_uid || !b_uid || a_uid===b_uid) return;
        result.push({ a_uid, b_uid, a_pts: +(a.points||0), b_pts: +(b.points||0), week:wk });
      });
    } catch {}
  }
  return result;
}
async function ensureRivalriesComputed(){
  if (Rivalries) return;
  const years = [2025, 2024, 2023, 2022, 2021];
  const pairs = new Map(); const usersSet = new Set();

  for (const yr of years){
    const lid = LEAGUES[yr] || (MANUAL[manualKey(yr)] ? manualKey(yr) : null);
    if (!lid) continue;
    const { users, rosters } = await fetchLeagueBundle(lid);
    (users||[]).forEach(u=> usersSet.add(u.user_id));

    if (isManualLeagueId(lid)) {
      // Manual (ESPN 2021) — use embedded matchups
      const teamIndex = new Map(); rosters.forEach(r => teamIndex.set(r.roster_id, r.owner_id));
      const m = (MANUAL[manualKey(yr)]?.matchups)||[];
      const byId = {};
      m.forEach(row => { (byId[row.matchup_id] ||= []).push(row); });
      Object.values(byId).forEach(g => {
        if (g.length !== 2) return; const [a,b] = g;
        const a_uid = teamIndex.get(a.roster_id), b_uid = teamIndex.get(b.roster_id); if (!a_uid||!b_uid||a_uid===b_uid) return;
        const key = pairKey(a_uid,b_uid);
        const bucket = pairs.get(key) || { a:a_uid, b:b_uid, games:[] };
        bucket.games.push({ a_uid, b_uid, a_pts:+(a.points||0), b_pts:+(b.points||0), season:yr, week:a.week });
        pairs.set(key, bucket);
      });
    } else {
      // Sleeper seasons: fetch all weeks
      const matchList = await fetchSeasonMatchupsAllWeeks(lid, rosters);
      matchList.forEach(g => {
        const key = pairKey(g.a_uid, g.b_uid);
        const bucket = pairs.get(key) || { a:g.a_uid, b:g.b_uid, games:[] };
        bucket.games.push({ ...g, season: yr });
        pairs.set(key, bucket);
      });
    }
  }

  Rivalries = { pairs, users: usersSet };
  const options = Array.from(Profiles.keys()).filter(uid => Rivalries.users.has(uid));
  options.sort((u1,u2)=> {
    const n1=(Profiles.get(u1)?.name||u1).toLowerCase();
    const n2=(Profiles.get(u2)?.name||u2).toLowerCase();
    return n1.localeCompare(n2);
  });
  rivalSelect.innerHTML = `<option value="">Select a manager…</option>` + options.map(uid => `<option value="${uid}">${esc(Profiles.get(uid)?.name || uid)}</option>`).join("");
}

function nearlyEqual(a, b, eps = 0.01) { // 0.01 pt tolerance
  if (a == null || b == null) return false;
  return Math.abs(Number(a) - Number(b)) < eps;
}

function renderRivalriesFor(uid){
  if (!uid || !Rivalries) { rivalWrap.innerHTML = `<div class="muted">Select a manager to see head-to-head records.</div>`; return; }
  const seenOpp = new Map();

  Rivalries.pairs.forEach(bucket => {
    const { a, b, games } = bucket;
    if (a !== uid && b !== uid) return;
    const opp = (a === uid) ? b : a;
    let w=0,l=0,t=0, pf=0, pa=0, meetings=0;
    games.forEach(g => {
      const myPts = (g.a_uid === uid) ? g.a_pts : g.b_pts;
      const opPts = (g.a_uid === uid) ? g.b_pts : g.a_pts;

/*       // treat tiny float differences as decisive, not ties
      if (nearlyEqual(myPts, opPts)) {
        // true tie only if *exact* equality within epsilon and BOTH non-null
        // If either side is missing, skip this game entirely (don’t count it)
        if (myPts != null && opPts != null) { t++; pf += myPts; pa += opPts; meetings++; }
        return;
      }

      // normal win/loss
      pf += myPts; pa += opPts; meetings++;
      if (myPts > opPts) w++; else l++; */
      
      if (myPts == null || opPts == null) {
      // skip incomplete games (don’t count)
        return;
      }

      if (nearlyEqual(myPts, opPts)) {
        t++;
      } else if (myPts > opPts) {
        w++;
      } else {
        l++;
      }


    });

    const stat = seenOpp.get(opp) || { w:0,l:0,t:0,pf:0,pa:0,meetings:0 };
    stat.w += w; stat.l += l; stat.t += t; stat.pf += pf; stat.pa += pa; stat.meetings += meetings;
    seenOpp.set(opp, stat);
  });

  const arr = Array.from(seenOpp.entries()).map(([opp, s]) => ({
    opp, ...s, diff: s.pf - s.pa, pct: s.meetings ? s.w / s.meetings : 0
  })).sort((a,b)=> b.pct - a.pct || b.diff - a.diff || b.pf - a.pf);

  const rowsHtml = arr.map(x => [
    nameCellForOwner(x.opp, Profiles.get(x.opp)?.name || x.opp),
    `${x.w}-${x.l}${x.t?'-'+x.t:''}`,
    x.meetings,
    Math.round(x.pf),
    Math.round(x.pa),
    (x.diff>=0?'+':'')+Math.round(x.diff),
    (x.pct*100).toFixed(1)+'%'
  ]);
  rivalWrap.innerHTML = table(["Opponent","W-L(-T)","Games","PF","PA","Diff","Win%"], rowsHtml);
}

/* ---------- Events ---------- */
el("#autoWeekBtn").addEventListener("click", getCurrentWeek);
el("#loadBtn").addEventListener("click", loadCurrentLeague);
el("#matchupsBtn").addEventListener("click", async () => {
  await loadMatchups();
  setActive('previews');
});
el("#genAllBtn").addEventListener("click", async () => {
  const week = Number(weekInput.value);
  const rosters = cache.rosters, users = cache.users;
  const matchups = cache.matchupsByWeek[week] || [];
  const groups = {};
  matchups.forEach(m => { const id = m.matchup_id ?? `solo-${m.roster_id}`; (groups[id] ||= []).push(m); });

  const cards = previewsWrap.querySelectorAll('.preview-card');
  for (const card of cards) {
    const mid = card.dataset.mid;
    const arr = groups[mid]; if (!arr || arr.length !== 2) continue;
    const [a,b] = arr;
    const ta = card.querySelector('textarea.preview');
    ta.value = "Generating…";
    try {
      ta.value = await generatePreviewLocal({
        week,
        a, b,
        teamNameA: (rosters.find(r=>r.roster_id===a.roster_id)?.settings?.team_name) || "Team A",
        teamNameB: (rosters.find(r=>r.roster_id===b.roster_id)?.settings?.team_name) || "Team B",
        rosters, users
      });
    } catch (e) { ta.value = `Could not generate: ${e.message}`; }
  }
});
el("#refreshAllTimeBtn").addEventListener("click", async () => {
  allTimeWrap.textContent = "Computing…";
  try { renderAllTimeTable(await computeAllTime()); }
  catch (e) { allTimeWrap.textContent = "Error: " + e.message; }
});
el("#refreshRivalsBtn").addEventListener("click", async () => {
  Rivalries = null;
  rivalWrap.textContent = "Recomputing…";
  await ensureRivalriesComputed();
  renderRivalriesFor(rivalSelect.value);
});
rivalSelect.addEventListener("change", () => renderRivalriesFor(rivalSelect.value));

/* ===================== ESPN 2021 Owner Mapping (ESPN -> Sleeper) ===================== */
// Fill with known mappings. Keys = ESPN owner IDs (from 2021 JSON). Values = Sleeper user_ids.
const OWNER_ID_MAP_2021 = {
  // "espn_owner_id_here": "sleeper_user_id_here"
};
function normName(s){ return String(s||"").trim().toLowerCase().replace(/\s+/g,' '); }
async function buildAutoMapFromSleeper(existingSeasons = [2025, 2024, 2023, 2022]) {
  const nameToSleeper = new Map();
  for (const yr of existingSeasons) {
    const lid = LEAGUES[yr];
    if (!lid) continue;
    try {
      const users = await fetchJson(`/league/${lid}/users`);
      users.forEach(u => {
        const nm = normName(u.display_name || u.username || u.user_id);
        if (nm && !nameToSleeper.has(nm)) nameToSleeper.set(nm, u.user_id);
      });
    } catch {}
  }
  return nameToSleeper;
}
async function applyOwnerMap2021(esUsers, esRosters) {
  const autoMap = await buildAutoMapFromSleeper();
  const idMap = new Map();

  Object.entries(OWNER_ID_MAP_2021).forEach(([espn, sleeper]) => idMap.set(String(espn), String(sleeper)));
  esUsers.forEach(u => {
    const espnId = String(u.user_id);
    if (idMap.has(espnId)) return;
    const nm = normName(u.display_name);
    const sleeperId = autoMap.get(nm);
    if (sleeperId) idMap.set(espnId, sleeperId);
  });

  const mergedUsers = new Map(); // sleeperId -> profile
  const remappedRosters = esRosters.map(r => {
    const source = String(r.owner_id);
    const target = idMap.get(source) || source;
    const u = esUsers.find(x => String(x.user_id) === source);
    const disp = (u?.display_name) || (`Manager ${target}`);
    const av = u?.avatar_url || null;
    const prof = Profiles.get(target);
    const finalName = prof?.name || disp;
    const finalAvatar = prof?.avatar || av;

    if (!mergedUsers.has(target)) {
      mergedUsers.set(target, { user_id: target, display_name: finalName, avatar_url: finalAvatar });
    } else {
      const prev = mergedUsers.get(target);
      mergedUsers.set(target, {
        user_id: target,
        display_name: prev.display_name || finalName,
        avatar_url: prev.avatar_url || finalAvatar
      });
    }

    return { ...r, owner_id: target, team_name: r.team_name };
  });

  const remappedUsers = Array.from(mergedUsers.values());
  registerProfilesFromManual(remappedUsers);
  return { users: remappedUsers, rosters: remappedRosters };
}

function espnExtractPoints(side) {
  const round2 = (x) => Math.round(Number(x) * 100) / 100;

  if (side && side.totalPoints != null) return round2(side.totalPoints);

  if (side && side.rosterForMatchup && side.rosterForMatchup.appliedStatTotal != null) {
    return round2(side.rosterForMatchup.appliedStatTotal);
  }

  if (side && side.pointsByScoringPeriod && typeof side.pointsByScoringPeriod === 'object') {
    let sum = 0, seen = false;
    for (const v of Object.values(side.pointsByScoringPeriod)) {
      if (v != null) { sum += Number(v); seen = true; }
    }
    if (seen) return round2(sum);
  }
  return null;
}



/* ===================== ESPN 2021: build bundle helper ===================== */
async function buildManualBundleFromESPN(data, seasonYear = 2021, fallbackLeagueName = "ESPN League 755639") {
  const teams = data.teams || [];
  const rawUsers = [];
  const rawRosters = [];
  const seen = new Set();

  const tName = t => (`${(t.location||"").trim()} ${(t.nickname||"").trim()}`.trim() || t.abbrev || `Team ${t.id}`);
  const tLogo = t => (t.logo||"").trim();
  const tRec  = t => {
    const rec = t.record || {}, o = rec.overall || {};
    return { w:+(o.wins||0), l:+(o.losses||0), pf:+(o.pointsFor||0), pa:+(o.pointsAgainst||0) };
  };
  const owner = t => (t.owners && t.owners[0]) || `unknown_${t.id}`;

  teams.forEach(t => {
    const uid = owner(t);
    if (!seen.has(uid)) {
      rawUsers.push({ user_id: String(uid), display_name: tName(t), avatar_url: tLogo(t) });
      seen.add(uid);
    }
    const r = tRec(t);
    rawRosters.push({
      roster_id: t.id,
      owner_id: String(uid),
      team_name: tName(t),
      wins: r.w, losses: r.l,
      fpts: +r.pf.toFixed(2),
      fpts_against: +r.pa.toFixed(2),
      streak: ""
    });
  });

  const { users, rosters } = await applyOwnerMap2021(rawUsers, rawRosters);

  const schedule = data.schedule || [];
  const matchups = [];
  const winners = [];
  let mid = 1, bid = 1000;

  schedule.forEach(s => {
    const h = s.home||{}, a = s.away||{};
    const hId = h.teamId, aId = a.teamId; if (hId==null || aId==null) return;
    const week = s.matchupPeriodId; if (week==null) return;
    const hPts = espnExtractPoints(h);
    const aPts = espnExtractPoints(a);

    // If either side has no points (null), skip this game entirely to avoid fake 0–0 ties.
    if (hPts == null || aPts == null) { mid++; return; }

    matchups.push({ week, matchup_id: mid, roster_id: hId, points: hPts });
    matchups.push({ week, matchup_id: mid, roster_id: aId, points: aPts });


    const playoffish = !!(s.playoffTierType || (s.matchupType && /CHAMP|PLAYOFF/i.test(s.matchupType)));
    if (playoffish) {
      const winnerSide = s.winner; let wRid = null;
      if (winnerSide === "HOME") wRid = hId;
      else if (winnerSide === "AWAY") wRid = aId;
      else wRid = (hPts >= aPts) ? hId : aId;
      winners.push({
        round: week, matchup_id: bid,
        roster_id_1: hId, roster_id_2: aId,
        t1_points: hPts, t2_points: aPts,
        winner_roster_id: wRid
      });
      bid++;
    }
    mid++;
  });

  let podium;
  if (!winners.length) {
    const lastWeek = Math.max(0, ...schedule.map(s => +s.matchupPeriodId || 0));
    const lastGames = schedule.filter(s => +s.matchupPeriodId === lastWeek);
    if (lastGames.length) {
      const best = lastGames.reduce((acc, s) => {
        const tot = +(s.home?.totalPoints||0) + +(s.away?.totalPoints||0);
        return (!acc || tot > acc.tot) ? { s, tot } : acc;
      }, null);
      if (best) {
        const s = best.s, hId = s.home.teamId, aId = s.away.teamId;
        const hPts = +(s.home.totalPoints||0), aPts = +(s.away.totalPoints||0);
        const champ = (hPts >= aPts) ? hId : aId;
        const runner = (champ === hId) ? aId : hId;
        podium = { champion: champ, runnerUp: runner, third: null };
      }
    }
  }
  if (!podium) podium = podiumFromBracket(winners);

  const leagueName = data?.settings?.name || fallbackLeagueName;
  return {
    season: seasonYear,
    league: { name: leagueName, total_rosters: teams.length },
    users, rosters, matchups, winners_bracket: winners,
    _podium: { champion: podium.champion ?? null, runnerUp: podium.runnerUp ?? null, third: podium.third ?? null }
  };
}

/* ===================== Manual season plumbing ===================== */
const ESPN_PUBLIC_2021_LEAGUE_ID = 755639;
const ESPN_2021_CACHE_KEY = "espn_ffl_2021_bundle_v1";
window.MANUAL = window.MANUAL || {};
function manualKey(year){ return `manual-${year}`; }
function isManualLeagueId(id){ return typeof id === "string" && id.startsWith("manual-"); }

/* Hook fetchLeagueBundle to support manual seasons */
const _orig_fetchLeagueBundle = fetchLeagueBundle;
fetchLeagueBundle = async function(leagueId) {
  if (isManualLeagueId(leagueId)) {
    const bundle = MANUAL[leagueId];
    if (!bundle) throw new Error(`Manual season not loaded: ${leagueId}`);
    registerProfilesFromManual(bundle.users);
    return {
      league: { season: String(bundle.season), name: bundle.league?.name || "Manual League", total_rosters: bundle.league?.total_rosters ?? (bundle.rosters?.length || 0) },
      users: bundle.users || [],
      rosters: (bundle.rosters || []).map(r => ({
        roster_id: r.roster_id,
        owner_id: r.owner_id,
        settings: { team_name: r.team_name, wins: r.wins ?? 0, losses: r.losses ?? 0, fpts: r.fpts ?? 0, fpts_against: r.fpts_against ?? 0 },
        metadata: { streak: r.streak || "" }
      })),
      podium: bundle._podium || { champion:null, runnerUp:null, third:null }
    };
  }
  return _orig_fetchLeagueBundle(leagueId);
};

/* Seed UI controls (only shown when auto import fails) */
function showEspnSeedUI() {
  const row = document.getElementById('espnSeedRow');
  if (row) row.style.display = 'flex';
}
async function seedESPN2021FromFile(file) {
  const text = await file.text();
  const data = JSON.parse(text);

  const bundle = await buildManualBundleFromESPN(data, 2021, "ESPN League 755639");
  localStorage.setItem(ESPN_2021_CACHE_KEY, JSON.stringify(bundle));
  MANUAL[manualKey(2021)] = bundle; LEAGUES[2021] = manualKey(2021);
  registerProfilesFromManual(bundle.users);

  await loadSeasonsSummary();
  const at = await computeAllTime();
  if (typeof renderAllTimeTable === "function") renderAllTimeTable(at);
}
// Wire seed button
(function(){
  const btn = document.getElementById('espnSeedBtn');
  const file = document.getElementById('espnSeedFile');
  if (!btn || !file) return;
  btn.addEventListener('click', ()=> file.click());
  file.addEventListener('change', async (e) => {
    const f = e.target.files?.[0]; if (!f) return;
    btn.disabled = true; btn.textContent = "Seeding…";
    try { await seedESPN2021FromFile(f); btn.textContent = "Seeded ✓"; }
    catch(err){ alert("Failed to seed: " + err.message); btn.disabled = false; btn.textContent = "Seed 2021 (from file)"; }
  });
})();

/* Auto-import ESPN 2021 (public). If fetch fails (CORS), show seed UI. Then init app. */
async function importESPN2021Public(espnLeagueId = ESPN_PUBLIC_2021_LEAGUE_ID) {
  const cached = localStorage.getItem(ESPN_2021_CACHE_KEY);
  if (cached) {
    try {
      const bundle = JSON.parse(cached);
      MANUAL[manualKey(2021)] = bundle; LEAGUES[2021] = manualKey(2021);
      registerProfilesFromManual(bundle.users);
      return;
    } catch {}
  }
  const url = `https://lm-api-reads.fantasy.espn.com/apis/v3/games/ffl/seasons/2021/segments/0/leagues/${espnLeagueId}?view=mTeam&view=mRoster&view=mMatchup&view=mSettings`;
  const res = await fetch(url, { headers: { "Accept": "application/json" } });
  if (!res.ok) throw new Error(`ESPN HTTP ${res.status}`);
  const data = await res.json();

  const bundle = await buildManualBundleFromESPN(data, 2021, `ESPN League ${espnLeagueId}`);
  localStorage.setItem(ESPN_2021_CACHE_KEY, JSON.stringify(bundle));
  MANUAL[manualKey(2021)] = bundle; LEAGUES[2021] = manualKey(2021);
  registerProfilesFromManual(bundle.users);
}

/* --- BOOTSTRAP --- */
(async () => {
  try { await importESPN2021Public(); }
  catch (e) { console.warn("ESPN 2021 import failed (likely CORS):", e); showEspnSeedUI(); }
  finally {
    getCurrentWeek();
    loadCurrentLeague();
    computeAllTime().then(renderAllTimeTable).catch(()=>{});
  }
})();

/* ---------- Rival select hook ---------- */
rivalSelect.addEventListener("change", () => renderRivalriesFor(rivalSelect.value));
</script>
</body>
</html>
